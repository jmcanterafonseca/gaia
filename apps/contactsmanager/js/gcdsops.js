/* exported GlobalMergedContacts */

'use strict';


// Class for working with the Global Contacts DataStore (GCDS).
// This class will deal with the object keeped, that follow
// this structure:
// {
//   id: <Generated by Datastore>
//   sequence<entry>
// }
// where entry is an object like: { uid: <originDsId>, origin: <OriginDs> }
// <originDsId> contains all the information that allows to locate the
//              concerned datastore
//

var GlobalMergedContacts = (function GCDSOps() {

  var store = null;
  var DS_NAME = 'Global_Contacts_Datastore';
  var INDEX_ID = 1;
  var isIndexDirty = false;
  var index;

  var init = function init() {
    contacts.Matcher.dataProvider = GlobalMergedContacts;

    return new Promise(function(resolve, reject) {
      if (!navigator.getDataStores) {
        reject();
        return;
      }

      if (store !== null) {
        resolve();
        return;
      }

      navigator.getDataStores(DS_NAME).then(function(stores) {
        store = stores[0];
        return loadIndex();
      }, reject).then(resolve, reject);
    });
  }

  function createIndex() {
    return {
      // By tel number and all its possible variants
      // (We are not supporting dups right now)
      byTel: Object.create(null),
      // Prefix tree for enabling searching by partial tel numbers
      treeTel: [],
      // Will contain all the index of contacts that come from a
      // specific store, indexed by contact uid
      byStore: Object.create(null),
      byEmail: Object.create(null)
    };
  }

  function setIndex(obj) {
    index = (obj || createIndex());
  }

  function loadIndex() {
    return new Promise(function(resolve, reject) {
      store.get(INDEX_ID).then(function(idx) {
        if (!idx) {
          console.log('The index does not exist!!!');
          var theIndex = createIndex();
          setIndex(theIndex);
          store.add(theIndex).then(resolve, reject);
          return;
        }
        isIndexDirty = false;
        setIndex(idx);
        resolve(idx);
      }, reject);
    });
  }

  function indexByPhone(obj, idx) {
    if (Array.isArray(obj.tel)) {
      obj.tel.forEach(function(aTel) {
        var variants = SimplePhoneMatcher.generateVariants(aTel.value);

        variants.forEach(function(aVariant) {
          index.byTel[aVariant] = index.byTel[aVariant] || [];
          index.byTel[aVariant].push(idx);
        });
        // To avoid the '+' char
        TelIndexer.index(index.treeTel, aTel.value.substring(1), idx);
      });
    }
  }

  function indexByEmail(obj, idx) {
    if (Array.isArray(obj.email)) {
      obj.email.forEach(function(aEmail) {
        index.byEmail[aEmail.value] = index.byEmail[aEmail.value] || [];
        index.byEmail[aEmail.value].push(idx);
      });
    }
  }

  function indexByStore(originStore, originDsId, globalDsId) {
    if (!originStore || !originStore.owner || !originDsId || !globalDsId) {
      return;
    }
    // TODO: Investigate, do we need to index by original id, or just
    // keep an array of gcds ids by this store?
    var storeIndex = index.byStore[originStore.owner];
    if (!storeIndex) {
      storeIndex = {};
      index.byStore[originStore.owner] = storeIndex;
    }

    storeIndex[originDsId] = globalDsId;
  }

  /**
   *   Adds a new object to the global DS
   *   originStore is the Store origin
   *   originStoreId is the object id in the origin datastore
   *
   */
  var add = function add(originStore, originDsId, contact) {
    return new Promise(function(resolve, reject) {
      console.log('Add GCDS called');

      var entry = {
        uid: originDsId,
        origin: originStore.owner
      };

      var callbacks = {
        onmatch: function(results) {
          var key = Object.keys(results)[0];

          store.get(results[key].matchingContact.id).then(
            function (entryToMerge) {
              doAppend(entry, originStore, entryToMerge, contact).
                                                          then(resolve, reject);
          });
        },
        onmismatch: function() {
           doAdd(entry, originStore, contact).then(resolve, reject);
        }
      };

      contacts.Matcher.match(contact, 'passive', callbacks);
    });
  };

  // Adds a new contact. Then it is indexed
  function doAdd(entry, originStore, contact) {
    var data = [entry];

    console.log('Going to add a new entry in the GCDS');

    return new Promise(function(resolve, reject) {
      store.add(data).then(function(globalDsId) {
        indexByPhone(contact, globalDsId);
        indexByEmail(contact, globalDsId);
        indexByStore(originStore, entry.uid, globalDsId);

        isIndexDirty = true;

        console.log('Added contact with id: ', globalDsId);
        console.log('Index content: ', JSON.stringify(index.byEmail));

        resolve(data);
      }, reject);
    });
  }

  // Append a contact to an specific index
  function doAppend(entry, originStore, globalDsId, contact) {
    return new Promise(function(resolve, reject) {
      store.get(globalDsId).then(function(obj) {
        if (!obj || !Array.isArray(obj)) {
          obj = [];
        }
        obj.push(entry);

        store.put(obj, globalDsId).then(function() {
          indexByPhone(contact, globalDsId);
          indexByStore(originStore, entry.uid, globalDsId);
          indexByEmail(contact, globalDsId);

          isIndexDirty = true;
          console.log('Merged contact into: ', globalDsId);
          resolve(entry);
        }, reject);
      }, reject);
    });
  }

  // Get a list of all contacts by this DS and perform
  // remove operations over it.
  var clear = function clear(originStore) {
    if (!index) {
      return Promise.reject();
    }

    var byStore = index.byStore[originStore.owner];

    if (!byStore) {
      return Promise.resolve();
    }

    var promises = [];
    Object.keys(byStore).forEach(function onKey(key) {
      promises.push(remove(originStore, key));
    });

    return Promise.all(promises);
  };

  // Removes an entry, from the DS, and the index (original ds index)
  var remove = function remove(originStore, originDsId, contact) {
    var globalDsId = index.byStore[originStore.owner][originDsId];
    if (!globalDsId) {
      return Promise.resolve();
    }

    return new Promise(function (resolve, reject) {
      store.get(globalDsId).then(function onEntry(entries) {
        if (!Array.isArray(entries)) {
          reject();
          return;
        }

        doRemove(entries, originStore, originDsId, globalDsId, contact).
                                                        then(resolve, reject);
      }, reject);
    });
  };

  var findBy = function findBy(field, strToFind) {
    console.log('Find by: ', field, strToFind);

    if (!field || !strToFind || !field.trim() || !strToFind.trim()) {
      return Promise.resolve([]);
    }

    return new Promise(function(resolve, reject) {
      var contactIds;

      if (field === 'tel') {
        contactIds = index.byTel[strToFind];
      }
      else if (field === 'email') {
        contactIds = index.byEmail[strToFind];
      }

      if (!contactIds) {
        resolve([]);
        return;
      }

      console.log('Found something: ', contactIds[0]);

      store.get(contactIds[0]).then(function(entry) {
        console.log('entry: ', JSON.stringify(entry));

        MultiContact.getData({
          id: contactIds[0],
          entryData: entry
        }).then(function success(contactData) {
            resolve([contactData]);
        });
      });
    });
  };

  function removePhoneIndex(deletedContact) {
    // Need to update the tel indexes
    if (Array.isArray(deletedContact.tel)) {
      deletedContact.tel.forEach(function(aTel) {
        TelIndexer.remove(index.treeTel, aTel.value.substring(1));

        var variants = SimplePhoneMatcher.generateVariants(aTel.value);
        variants.forEach(function(aVariant) {
          delete index.byTel[aVariant];
        });
      });
    }
  }

  // Remove one component from a contact. We have two cases, a contact
  // with a single component (direct), or a contact that is compound
  // by several entries
  //
  // @param entries Array of objects containing the components of a contact
  // @param originStore Source datastore for the component we want remove
  // @param originDsId index of the global merged contact
  // @param globalDsId index of the contact in the origin datastore
  function doRemove(entries, originStore, originDsId, globalDsId, contact) {
    return new Promise(function (resolve, reject) {
      var position = -1;
      entries.forEach(function onEntry(entry, i) {
        if (entry.origin === originStore.owner && entry.uid == originDsId) {
          position = i;
        }
      });

      if (position !== -1) {
        entries.splice(position, 1);
      }

      // Remove indexes
      // TODO: Remove indexes by phone
      var storeIndex = index.byStore[originStore.owner];
      delete storeIndex[originDsId];
      if (Object.keys(storeIndex).length === 0) {
        delete index.byStore[originStore.owner];
      }
      if (contact) {
        removePhoneIndex(contact);
      }

      // Update entry
      isIndexDirty = true;
      if (entries.length === 0) {
        store.remove(globalDsId).then(resolve, reject);
      } else {
        store.put(entries, globalDsId).then(resolve, reject);
      }
    });
  }

  var flush = function flush() {
    if (!store) {
      return Promise.reject();
    }

    if (!isIndexDirty) {
      return Promise.resolve();
    }
    // Not really accurate
    isIndexDirty = false;
    return store.put(index, INDEX_ID);
  };

  return {
    init: init,
    add: add,
    remove: remove,
    flush: flush,
    clear: clear,
    get revisionId() {
      return store.revisionId
    },
    findBy: findBy
  };

})();
