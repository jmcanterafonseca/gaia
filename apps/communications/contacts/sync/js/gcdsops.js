/* exported GlobalMergedContacts */

'use strict';


// Class for working with the Global Contacts DataStore (GCDS).
// This class will deal with the object keeped, that follow
// this structure:
// {
//   id: <Generated by Datastore>
//   sequence<entry>
// }
// where entry is an object like: { uid: <originDsId>, origin: <OriginDs> }
// <originDsId> contains all the information that allows to locate the
//              concerned datastore
//

var GlobalMergedContacts = (function GCDSOps() {

  var store = null;
  var DS_NAME = 'Global_Contacts_Datastore';
  var INDEX_ID = 1;
  var isIndexDirty = false;
  var index;

  var init = function init() {
    if (!navigator.getDataStores) {
      return Promise.reject(null);
    }
    if (store !== null) {
      return Promise.resolve(store);
    }

    var promise = new Promise(function(resolve, reject) {
      navigator.getDataStores(DS_NAME).then(function(stores) {
        store = stores[0];
        resolve(store);
      }, reject);
    });

    promise.then(loadIndex);

    return promise;
  };

  function createIndex() {
    return {
      // By tel number and all its possible variants
      // (We are not supporting dups right now)
      byTel: Object.create(null),
      // Prefix tree for enabling searching by partial tel numbers
      treeTel: [],
      // Will contain all the index of contacts that come from a
      // specific store, indexed by contact uid
      byStore: Object.create(null)
    };
  }

  function setIndex(obj) {
    index = (obj || createIndex());
  }

  function loadIndex() {
    return new Promise(function(resolve, reject) {
      store.get(INDEX_ID).then(function(idx) {
        isIndexDirty = false;
        setIndex(idx);
        resolve(idx);
      }, reject);
    });
  }

  // Returns -1 if not mergeable by phone number or the
  // GlobalDatastoreId that should be added to.
  function getEntryIdToMerge(contact) {
    if (!Array.isArray(contact.tel) || contact.tel.length === 0) {
      return -1;
    }

    var entryId = -1;
    for (var i = 0; i < contact.tel.length; i++) {
      var tel = contact.tel[i];
      if (!tel.value) {
        continue;
      }

      var variants = SimplePhoneMatcher.generateVariants(tel.value);
      variants.forEach(function(variant) {
        if (index.byTel[variant]) {
          entryId = index.byTel[variant];
          return entryId;
        }
      });
    }

    return entryId;
  }

  function indexByPhone(obj, idx) {
    if (Array.isArray(obj.tel)) {
      obj.tel.forEach(function(aTel) {
        var variants = SimplePhoneMatcher.generateVariants(aTel.value);

        variants.forEach(function(aVariant) {
          index.byTel[aVariant] = idx;
        });
        // To avoid the '+' char
        TelIndexer.index(index.treeTel, aTel.value.substring(1), idx);
      });
    }
  }

  function indexByStore(originStore, originDsId, globalDsId) {
    if (!originStore || !originStore.owner || !originDsId || !globalDsId) {
      return;
    }
    // TODO: Investigate, do we need to index by original id, or just
    // keep an array of gcds ids by this store?
    var storeIndex = index.byStore[originStore.owner];
    if (!storeIndex) {
      storeIndex = {};
      index.byStore[originStore.owner] = storeIndex;
    }

    storeIndex[originDsId] = globalDsId;
  }

  /**
   *   Adds a new object to the global DS
   *   originStore is the Store origin
   *   originStoreId is the object id in the origin datastore
   *
   */
  var add = function add(originStore, originDsId, contact) {
    return new Promise(function(resolve, reject) {
      var entry = {
        uid: originDsId,
        origin: originStore.owner
      };
      var entryToMerge = getEntryIdToMerge(contact);

      if (entryToMerge !== -1) {
        doAppend(entry, originStore, entryToMerge, contact).
          then(resolve, reject);
      } else {
        doAdd(entry, originStore, contact).
          then(resolve, reject);
      }
    });
  };

  // Adds a new contact. Then it is indexed
  function doAdd(entry, originStore, contact) {
    var data = [entry];

    return new Promise(function(resolve, reject) {
      store.add(data).then(function(globalDsId) {
        indexByPhone(contact, globalDsId);
        indexByStore(originStore, entry.uid, globalDsId);
        isIndexDirty = true;

        console.log('Added contact with id: ', globalDsId);
        resolve(data);
      }, reject);
    });
  }

  // Append a contact to an specific index
  function doAppend(entry, originStore, globalDsId, contact) {
    return new Promise(function(resolve, reject) {
      store.get(globalDsId).then(function(obj) {
        if (!obj || !Array.isArray(obj)) {
          obj = [];
        }
        obj.push(entry);

        store.put(obj, globalDsId).then(function() {
          indexByPhone(contact, globalDsId);
          indexByStore(originStore, entry.uid, globalDsId);

          isIndexDirty = true;
          console.log('Merged contact into ', globalDsId);
          resolve(entry);
        }, reject);
      }, reject);
    });
  }

  // Get a list of all contacts by this DS and perform
  // remove operations over it.
  var clear = function clear(originStore) {
    if (!index) {
      return Promise.reject();
    }

    var byStore = index.byStore[originStore.owner];

    if (!byStore) {
      return Promise.resolve();
    }

    var promises = [];
    Object.keys(byStore).forEach(function onKey(key) {
      promises.push(remove(originStore, key));
    });

    return Promise.all(promises);
  };

  // Removes an entry, from the DS, and the index (original ds index)
  var remove = function remove(originStore, originDsId, contact) {
    var globalDsId = index.byStore[originStore.owner][originDsId];
    if (!globalDsId) {
      return Promise.resolve();
    }

    return new Promise(function (resolve, reject) {
      store.get(globalDsId).then(function onEntry(entries) {
        if (!Array.isArray(entries)) {
          reject();
          return;
        }

        doRemove(entries, originStore, originDsId, globalDsId, contact).
                                                        then(resolve, reject);
      }, reject);
    });
  }

  function removePhoneIndex(deletedContact) {
    // Need to update the tel indexes
    if (Array.isArray(deletedContact.tel)) {
      deletedContact.tel.forEach(function(aTel) {
        TelIndexer.remove(index.treeTel, aTel.value.substring(1));

        var variants = SimplePhoneMatcher.generateVariants(aTel.value);
        variants.forEach(function(aVariant) {
          delete index.byTel[aVariant];
        });
      });
    }
  }

  // Remove one component from a contact. We have two cases, a contact
  // with a single component (direct), or a contact that is compound
  // by several entries
  //
  // @param entries Array of objects containing the components of a contact
  // @param originStore Source datastore for the component we want remove
  // @param originDsId index of the global merged contact
  // @param globalDsId index of the contact in the origin datastore
  function doRemove(entries, originStore, originDsId, globalDsId, contact) {
    return new Promise(function (resolve, reject) {
      var position = -1;
      entries.forEach(function onEntry(entry, i) {
        if (entry.origin === originStore.owner && entry.uid == originDsId) {
          position = i;
        }
      });

      if (position !== -1) {
        entries.splice(position, 1);
      }

      // Remove indexes
      // TODO: Remove indexes by phone
      var storeIndex = index.byStore[originStore.owner];
      delete storeIndex[originDsId];
      if (Object.keys(storeIndex).length === 0) {
        delete index.byStore[originStore.owner];
      }
      if (contact) {
        removePhoneIndex(contact);
      }

      // Update entry
      isIndexDirty = true;
      if (entries.length === 0) {
        store.remove(globalDsId).then(resolve, reject);
      } else {
        store.put(entries, globalDsId).then(resolve, reject);
      }
    });
  }

  var flush = function flush() {
    if (!store) {
      return Promise.reject();
    }

    if (!isIndexDirty) {
      return Promise.resolve();
    }
    // Not really accurate
    isIndexDirty = false;
    return store.put(index, INDEX_ID);
  };

  return {
    init: init,
    add: add,
    remove: remove,
    flush: flush,
    clear: clear
  };

})();
